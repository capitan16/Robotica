
# üê¢ ROS2 TurtleSim Shape Drawer

Este proyecto permite controlar una tortuga de **Turtlesim** en ROS2 usando el teclado, con funcionalidades adicionales para que la tortuga dibuje letras en pantalla como `M`, `A`, `L`, `O`, `C`, `D` y `S`. ¬°Una manera divertida de interactuar con Turtlesim y practicar control de robots en ROS2!

---

## üì¶ Requisitos

- Python 3
- ROS2 Humble
- Paquete `turtlesim` instalado
- Terminal compatible con entrada de teclas sin eco (ej. terminal de Linux o macOS)

---

## üöÄ Instalaci√≥n y Ejecuci√≥n

1. **Configura tu espacio de trabajo ROS2**

   ```bash
   source /opt/ros/humble/setup.bash
   ```

2. **Clona este repositorio** en tu carpeta `src` de tu workspace:

   ```bash
   cd ~/ros2_ws/src
   git clone <URL-del-repositorio>
   cd ~/ros2_ws
   colcon build
   source install/setup.bash
   ```

3. **Lanza el simulador de la tortuga** en un terminal:

   ```bash
   ros2 run turtlesim turtlesim_node
   ```

4. **Ejecuta el controlador** en otro terminal:

   ```bash
   ros2 run my_turtle_controller move_turtle
   ```

---

## üéÆ Controles de Teclado

### Movimiento Manual

| Tecla         | Acci√≥n                      |
|---------------|-----------------------------|
| ‚Üë (flecha arriba)    | Avanzar               |
| ‚Üì (flecha abajo)     | Retroceder            |
| ‚Üê (flecha izquierda) | Girar a la izquierda  |
| ‚Üí (flecha derecha)   | Girar a la derecha    |
| `+`           | Aumentar velocidad lineal y angular |
| `-`           | Disminuir velocidad lineal y angular |

### Dibujo de Letras

Presiona una de las siguientes teclas para iniciar el trazado de la letra correspondiente. Durante el dibujo, puedes presionar `q` para interrumpir.

| Tecla | Letra | Descripci√≥n              |
|-------|-------|--------------------------|
| `m`   | M     | Dibuja la letra 'M' mediante segmentos rectos.|  
| `a`   | A     | Dibuja la letra 'A' con forma correcta y giro inicial.|  
| `l`   | L     | Dibuja la letra 'L' con movimiento vertical y horizontal.|  
| `o`   | O     | Dibuja la letra 'O' como un c√≠rculo completo.|  
| `c`   | C     | Dibuja la letra 'C' como un arco mayoritario.|  
| `d`   | D     | Dibuja la letra 'D' combinando l√≠nea vertical y arco.|
| `s`   | S     | Dibuja la letra 'S' combinando dos arcos.|
| `q`   | Q     | Salir del programa       |

---

## üß© Descripci√≥n de Clases y M√≥dulos

### `ShapeGenerator`

- **Prop√≥sito**: Proporciona m√©todos para generar curvas y rotar puntos y formas.
- **M√©todos clave**:
  - `rotate_point(point, angle)`: Rota un punto `(x, y)` por un √°ngulo dado.
  - `generate_arc_segments(radius, start_angle, end_angle, num_segments)`: Devuelve segmentos relativos que describen un arco de c√≠rculo.
  - `rotate_shape(points, angle)`: Rota una lista de puntos relativos por un √°ngulo.

### `LetterShapes`

- **Prop√≥sito**: Define las trayectorias relativas de cada letra que la tortuga debe seguir.
- **Constructor**:
  - `base_scale`: Escala general de las letras.
  - `num_arc_full` y `num_arc_part`: N√∫mero de segmentos para arcos completos y parciales.
- **Atributos**:
  - `self.shapes`: Diccionario que asocia cada letra (`'m'`, `'a'`, etc.) con una lista de segmentos relativos `(dx, dy)`.

### `KeyboardControllerNode` (subclase de `rclpy.node.Node`)

- **Prop√≥sito**: Nodo central que maneja la entrada de teclado, publica comandos de velocidad y controla el dibujo de formas.
- **Atributos importantes**:
  - `cmd_pub`: Publicador de mensajes `Twist` en `/turtle1/cmd_vel`.
  - `pose_sub`: Suscriptor a `/turtle1/pose` para obtener la posici√≥n actual.
  - `shape_bindings`: Mapeo de teclas a las formas definidas en `LetterShapes`.
  - `speed`, `turn`: Velocidades base lineal y angular.
  - `drawing`, `interrupt`: Flags para controlar la ejecuci√≥n de dibujo y posibles interrupciones.
- **M√©todos clave**:
  - `keyboard_loop()`: Bucle que captura y procesa pulsaciones de teclas.
  - `execute_trajectory(rel_points)`: Convierte puntos relativos en metas absolutas y las recorre.
  - `move_to_goal(gx, gy)`: Control proporcional (P-control) para mover la tortuga hasta `(gx, gy)`.
  - `pose_cb(msg)`: Callback para actualizar la posici√≥n actual de la tortuga.
  - `publish(lin, ang)`: Publica una velocidad lineal y angular.

### Funciones Auxiliares

- `normalize_angle(a)`: Normaliza un √°ngulo para que quede entre `-œÄ` y `œÄ`.
- `print_current_speeds(spd, trn)`: Imprime en consola las velocidades actuales.

---

## ‚öôÔ∏è Flujo de Ejecuci√≥n

1. `main()`: Guarda la configuraci√≥n de terminal, inicializa ROS2 y crea la instancia de `KeyboardControllerNode`.
2. Se lanza ROS2 y se espera la primera pose de la tortuga.
3. El hilo `keyboard_loop` captura pulsaciones, env√≠a comandos inmediatos o lanza hilos de dibujo.
4. Para cada letra, `execute_trajectory` calcula metas y usa `move_to_goal` para un trazado suave.
5. Se puede interrumpir el dibujo con `q` o usar flechas para control manual en cualquier momento.

---

## Preparaci√≥n de Trayectorias
La estrategia fundamental para dibujar las formas (letras) es definirlas como una secuencia de movimientos relativos. Cada forma se almacena como una lista de vectores (dx, dy). Cada vector indica cu√°nto debe moverse la tortuga en sus ejes X (adelante/atr√°s) e Y (izquierda/derecha) locales para alcanzar el siguiente punto clave de la forma, partiendo desde donde termin√≥ el movimiento anterior.

El proceso se puede dividir en varias etapas clave:
### Etapa 1: Definici√≥n de la Trayectoria como Vectores Relativos:

Cada forma se define como una secuencia de movimientos relativos al punto anterior 

- **Representaci√≥n:** Para ello usamos una  lista de tuplas (dx, dy), donde cada tupla representa un segmento de la trayectoria. dx es el cambio en la coordenada X y dy es el cambio en la coordenada Y para ese segmento espec√≠fico. 

```python
 # Forma 'A'

        a_scale = base_scale
        a_height = 1.0 * a_scale
        a_width = 1.0 * a_scale
        self.a_shape_relative = [
             (a_width / 2.0, a_height),
             (a_width / 2.0, -a_height),
             (-a_width / 4.0, a_height / 2.0),
             (-a_width / 2.0, 0.0)
        ]

```
- **Escalado:**  Se usa una variable base_scale para ajustar el tama√±o general de las formas de manera consistente. Las definiciones multiplican las dimensiones base por esta escala. 

### Como definimos estas taryectorias?

- `De forma directa`: Para formas compuestas por l√≠neas rectas (como 'M', 'A', 'L'), las tuplas (dx, dy) se escriben directamente en el c√≥digo, calculadas a partir de las dimensiones deseadas (altura, anchura)


- `Generacion de arcos`:
Para formas curvas ('O', 'C', 'D'), no es pr√°ctico definir manualmente cada segmento. Se usa la funci√≥n **generate_arc_segments**.
Lo que queremos es aproximar un arco circular mediante una secuencia de peque√±os segmentos rectos (vectores relativos)

    **Par√°metros:**

    - `radius`: El radio del arco.  
    - `start_angle_rad`: El √°ngulo (en radianes) donde comienza el arco en un c√≠rculo centrado en (0,0).  
    - `end_angle_rad`: El √°ngulo (en radianes) donde termina el arco.  
    - `num_segments`: En cu√°ntos peque√±os segmentos rectos se dividir√° el arco. M√°s segmentos = curva m√°s suave pero m√°s puntos a procesar.

        ```python
        # Ejemplo: Generaci√≥n de la 'O' original (c√≠rculo completo)
        o_radius = 0.7 * base_scale
        o_shape_orig = self.generate_arc_segments(
            o_radius, math.pi, 3 * math.pi, num_arc_segments_full 
        )
        ```
        `Resultado`: Devuelve una lista de tuplas (dx, dy) que, si se suman consecutivamente, aproximan el arco deseado.

- `Combinaci√≥n de Segmentos`: Formas como la 'D' combinan segmentos rectos y curvos. Se definen por separado y luego se concatenan sus listas de vectores relativos.

    ```python
            d_line = (0.0, d_height) # Vector recto inicial
            d_arc_segments = self.generate_arc_segments(...) 
            d_shape_orig = [d_line] + d_arc_segments # Se unen las listas

    ``` 

### Etapa 2: Pre-Rotaci√≥n de Definiciones

Algunas formas (como 'O', 'C', 'D') se generan con una orientaci√≥n "natural" basada en los √°ngulos usados en generate_arc_segments. Sin embargo, se desea que al presionar la tecla, la tortuga comience a dibujar la forma movi√©ndose "hacia adelante" (en la direcci√≥n de su eje X local). Para lograr esto, estas definiciones se pre-rotan antes de ser almacenadas.
Usamos `rotate_shape_definitionrotate_shape_definition`

**Par√°metros:**

- `relative_points`: La lista original de vectores (dx, dy) a rotar.  
- `angle_rad`: El √°ngulo (en radianes) que se desea rotar la definici√≥n completa.

```python
angle_to_align_with_x = -math.pi / 2.0
self.o_shape_relative = self.rotate_shape_definition(o_shape_orig, angle_to_align_with_x)
self.c_shape_relative = self.rotate_shape_definition(c_shape_orig, angle_to_align_with_x)

```

### Etapa 3: Almacenamiento de las Definiciones Finales:

Las listas finales de vectores relativos (algunas pre-rotadas, otras no) se almacenan en un diccionario llamado shape_bindings.

```python 
self.shape_bindings = {
    'm': self.m_shape_relative,
    'a': self.a_shape_relative,
    'o': self.o_shape_relative, # Contiene la definici√≥n ya pre-rotada
    # -----
}
```
Esto permite seleccionar f√°cilmente la "plantilla" correcta cuando el usuario presiona una tecla.

### Etapa 4: Preparaci√≥n para la Ejecuci√≥n (C√°lculo de Puntos Objetivo Absolutos)
 Despu√©s de que el usuario presiona una tecla de forma v√°lida (ej: 'm') y antes de que el robot empiece a moverse realmente. Se realiza dentro de la funci√≥n `execute_trajectory`.

 Disparador: El keyboard_loop detecta una tecla v√°lida (ej: 'm'), busca la lista de vectores relativos correspondiente en `shape_bindings`, y lanza un hilo (thread) para ejecutar `execute_trajectory` pas√°ndole esa lista.

Algo crucial dentro de execute_trajectory es obtener la pose actual del robot **(posici√≥n y orientaci√≥n)** en el momento en que se inicia el dibujo. 

```python
start_pose = self.get_current_pose_safe()
# start_pose contiene .x, .y, .theta (√°ngulo actual de la tortuga)
start_angle = start_pose.theta
current_x, current_y = start_pose.x, start_pose.y
```

### Etapa 5 .Calcular Objetivos Absolutos

- Se rota cada vector relativo `(dx, dy)` por el √°ngulo inicial `start_angle`.
- Se suma el vector rotado a la √∫ltima posici√≥n absoluta calculada para obtener el siguiente punto objetivo `(X, Y)`.
- Se guarda el punto `(X, Y)` en `absolute_goals`.

Un paso intermedio es verificar si este (goal_x, goal_y) calculado est√° dentro de los l√≠mites permitidos del canvas de Turtlesim (`check_boundaries`). Si no, la trayectoria se invalida.

### Etapa 6  Listo para Seguir: 

 La lista ```absolute_goals``` est√° completa y lista para ser pasada (elemento por elemento) a la l√≥gica de control de movimiento (move_to_goal). 

Para ilustrarlo de forma m√°s clara, utilizamos MATLAB y extra√≠mos varias de las funciones clave del proceso de generaci√≥n de la trayectoria, encapsul√°ndolas en un script que muestra √∫nicamente la parte esencial previamente descrita.

En este ejemplo dibujaremos las letras asumiendo que la tortuga se encuentra en la posici√≥n x=2x=2, y=3y=3, orientada a 45 grados y utilizando una escala de 1.5, cada vez que se presione la tecla correspondiente.

```Letra A:```
![LetraA](img/LetraA.png)


[LetraA_r_45.webm](https://github.com/user-attachments/assets/bc5d2df5-a225-4462-81d3-45f9fbeaff7e)

Ahora el angulo va hacer -$\pi$

![LetraA](img/LetraARotada.png)

Letra M a $\pi/2$

![LetraM](img/LetraM.png)

[LetraM.webm](https://github.com/user-attachments/assets/8a5969aa-182b-4df7-acf8-55fc376a94e3)



Letra L

![LetraL](img/LetraL1.png)

[LetraL.webm](https://github.com/user-attachments/assets/8d5a4803-6c48-405c-8f46-beeb63200227)


Ahora Por ejemplo Probemos la letra C que es curva:


![LetraC](img/letraC180.png)

Ahora veamos a $\pi/2$


![LetraC](img/LetraC90.png)


[LetraC.webm](https://github.com/user-attachments/assets/5e6b93f1-5d03-4309-b66e-a244579ccc4a)


Tenemos la letra O :



![LetraO](img/letroOCero.png)

[LetraO.webm](https://github.com/user-attachments/assets/cae7aacd-f550-44ab-9113-e338aa003cb8)

Asi mismo nos encontramos con la letra S:

![LetraS](img/trayectoriaS.jpg)

[LetraS.webm](https://github.com/user-attachments/assets/34e84d91-3634-4bf3-9b15-934e0f25630e)




Esta es la idea general del proceso. Finalmente, dibujaremos la letra D, que combina una parte curva y una parte recta. Con estas tres letras ya podr√≠amos cubrir de manera general el abanico de formas presentes en el abecedario.

Orientada a 0 grados

![LetraD](img/LetraDCero.png)


Orientada a 90 grados:

![LetraD](img/LetraD90.png)

[LetraD.webm](https://github.com/user-attachments/assets/12e7ac4f-bc0f-47b7-9ec5-257cdd2085f0)


### Seguimiento de la Trayectoria en Este Sistema

El seguimiento de la trayectoria, es decir, c√≥mo la tortuga se mueve f√≠sicamente de un punto a otro de la letra, es manejado principalmente por la funci√≥n `move_to_goal` en combinaci√≥n con el bucle de ejecuci√≥n en `execute_trajectory`. As√≠ es como funciona:

1.  **Secuencia de Objetivos**: Primero, execute_trajectory calcula todas las coordenadas absolutas (goal_x, goal_y) que componen la forma, bas√°ndose en los vectores relativos y la orientaci√≥n inicial de la tortuga.

2. **Movimiento Punto a Punto** : Luego, execute_trajectory entra en un bucle que itera sobre esta lista de puntos objetivo. En cada iteraci√≥n, le pasa el siguiente  (goal_x, goal_y) a la funci√≥n move_to_goal.
3. **Control** `move_to_goal`: Esta es la funci√≥n clave para el movimiento real.  Implementa un controlador proporcional (P) en bucle cerrado.

    - **Retroalimentaci√≥n** : En cada iteraci√≥n del bucle, lo primero que hace es obtener la pose actual de la tortuga (current_pose = self.get_current_pose_safe()). Esto es crucial, es la retroalimentaci√≥n que le dice al sistema d√≥nde est√° realmente la tortuga.
    - **C√°lculo del Error**: Compara la pose actual con el objetivo deseado:
        - Calcula el vector directo desde la posici√≥n actual hasta el punto deseado.
        - Determina la distancia restante hasta el goal.
        - Calcula el √°ngulo hacia el goal (angle_to_goal) usando math.atan2(dy, dx).
        - Calcula el error angular (angle_error): la diferencia entre el angle_to_goal y la orientaci√≥n actual de la tortuga (current_pose.theta). Se normaliza para que est√© entre ‚àíœÄ y œÄ.
4. **Ley de Control** : Decide qu√© velocidad aplicar bas√°ndose en el error:
    - `Velocidad Angular` : Se calcula como angular_vel = KP_ANGULAR * angle_error. Es decir, la velocidad de giro es proporcional a cu√°nto necesita girar la tortuga. Si el error es grande, gira r√°pido; si es peque√±o, gira despacio. 
    - `Velocidad Lineal`: Se calcula como linear_vel = KP_LINEAR * distance, pero solo si el error angular es suficientemente peque√±o (abs(angle_error) < GOAL_TOLERANCE_ANGLE). Esto significa que la tortuga primero gira para encarar el objetivo y solo entonces avanza. La velocidad de avance es proporcional a la distancia restante. KP_LINEAR es la ganancia proporcional lineal.
5. **Actuaci√≥n** : Las velocidades calculadas (linear_vel, angular_vel) se empaquetan en un mensaje Twist y se publican en el t√≥pico /turtle1/cmd_vel usando publish_velocity. El simulador turtlesim recibe este mensaje y mueve la tortuga en consecuencia.

6. **Condici√≥n de Salida**: El bucle interno de move_to_goal termina cuando la distance al objetivo es menor que una peque√±a tolerancia (GOAL_TOLERANCE_DIST).

7. **Repetici√≥n** : Una vez que move_to_goal termina (ha alcanzado un waypoint), el control vuelve al bucle de execute_trajectory, que entonces llama a move_to_goal para el siguiente punto  de la lista, repitiendo el proceso hasta completar la forma.


## Diagramas de clases y de flujo 
### Descripci√≥n del Diagrama de Clases

- **ShapeGenerator**: M√©todos est√°ticos para rotar puntos y generar/rotar arcos.
- **LetterShapes**: Inicializa vectores relativos de cada letra (M, A, L, O, C, D, S).
- **KeyboardControllerNode**:  
  - Publica `Twist` y suscribe `Pose`.  
  - Captura teclas, ajusta velocidad, mueve manualemente o dibuja formas.
  - M√©todos claves: `keyboard_loop()`, `execute_trajectory()`, `move_to_goal()`.

---

```mermaid
classDiagram
    %% Clases externas de ROS
    class Node 
    class Twist 
    class Pose 

    %% Generador de formas b√°sicas
    class ShapeGenerator {
      +static rotate_point(point, angle): (float, float)
      +generate_arc_segments(radius, start_angle, end_angle, num_segments): List
      +rotate_shape(points, angle): List
    }

    %% Definici√≥n de las formas de cada letra
    class LetterShapes {
      +m: List
      +a: List
      +l: List
      +o: List
      +c: List
      +d: List
      +s: List
      +shapes: Map
      +__init__(base_scale=1.5, num_arc_full=32, num_arc_part=24)
    }

    %% Nodo principal de control de teclado
    class KeyboardControllerNode {
      -settings
      -cmd_pub: Publisher
      -pose_sub: Subscription
      -current_pose: Pose
      -pose_lock: Lock
      -speed: float
      -turn: float
      -manual_x: float
      -manual_th: float
      -drawing: bool
      -interrupt: bool
      -thread: Thread
      -shape_bindings: Map
      -key_thread: Thread
      +__init__(settings)
      +pose_cb(msg: Pose)
      +wait_for_pose()
      +publish(lin, ang)
      +keyboard_loop()
      +execute_trajectory(rel_points)
      +move_to_goal(gx, gy): bool
      +destroy()
    }

    %% Relaciones
    KeyboardControllerNode --|> Node
    KeyboardControllerNode ..> Twist
    KeyboardControllerNode ..> Pose
    KeyboardControllerNode ..> LetterShapes
    KeyboardControllerNode ..> ShapeGenerator
    LetterShapes ..> ShapeGenerator
```

### Descripci√≥n del Diagrama de Flujo

1. **Inicio**: Init ROS, `wait_for_pose()`, mostrar ayuda.  
2. **Bucle de teclado**: Detecta teclas ‚Üí mueve, ajusta velocidad, dibuja o sale.  
3. **Dibujo**:  
   - Calcula metas desde vectores.  
   - Para cada meta, ejecuta control proporcional (`move_to_goal`).  
4. **Cierre**: Destruye nodo, detiene tortuga y restaura terminal.

```mermaid
flowchart TD
    %% Inicio del programa
    Start([Start]) --> Init[Initialize ROS & Node]
    Init --> WaitPose[wait_for_pose]
    WaitPose --> PrintHelp[Print speeds & help message]
    PrintHelp --> KeyboardLoop[Launch keyboard loop]

    %% Bucle principal de teclado
    subgraph MainLoop [Keyboard Loop]
      KeyboardLoop --> KeyCheck{Key press?}
      KeyCheck -->|No key| Idle[Check manual_x/manual_th ‚Üí publish 0]
      KeyCheck -->|Arrow key| ManualMove[Publish manual velocity]
      KeyCheck -->|+ or -| AdjustSpeed[Adjust speeds & print]
      KeyCheck -->|Letter key| DrawStart[Spawn execute_trajectory thread]
      KeyCheck -->|q| Quit[Break loop]
      Idle --> KeyboardLoop
      ManualMove --> KeyboardLoop
      AdjustSpeed --> KeyboardLoop
      DrawStart --> KeyboardLoop
      Quit --> Shutdown[Exit loop]
    end

    %% Subproceso de dibujo de formas
    subgraph Drawing [execute_trajectory]
      DrawStart --> ComputeGoals[Compute absolute goal points]
      ComputeGoals --> ForEach[For each goal point]
      ForEach --> MoveToGoal[move_to_goal gx, gy]
      MoveToGoal --> CheckDone{Reached? or Interrupted?}
      CheckDone -->|Yes & more pts| ForEach
      CheckDone -->|Interrupted/Fail| Abort[Abort drawing]
      CheckDone -->|All reached| Complete[Finish drawing]
      Abort --> EndDraw[Set drawing=false]
      Complete --> EndDraw
      EndDraw --> Return[Return to Keyboard Loop]
    end

    %% Cierre del programa
    Shutdown --> Cleanup[Destroy node & shutdown ROS]
    Cleanup --> Restore[Restore terminal settings]
    Restore --> End([End])

```


## Conclusiones

### Importancia de la ley de control proporcional (P)
A lo largo del proyecto, qued√≥ demostrada la efectividad de un control proporcional puro en la funci√≥n `move_to_goal()`. Con una √∫nica ganancia (KP_LINEAR y KP_ANGULAR), logramos una respuesta inmediata y proporcional al error de posici√≥n y orientaci√≥n. Este enfoque sencillo facilit√≥ tanto la sintonizaci√≥n como la comprensi√≥n de la din√°mica general: a mayor error, mayor correcci√≥n aplicada, siempre dentro de l√≠mites establecidos.

### Enfoque ‚ÄúGo-To-Goal‚Äù y tolerancias
Implementamos exitosamente la estrategia ‚ÄúGo-To-Goal‚Äù, basada en el c√°lculo continuo de la distancia y el error angular respecto al objetivo. Definir tolerancias adecuadas (GOAL_TOLERANCE_DIST, GOAL_TOLERANCE_ANGLE) permiti√≥ que el robot se detuviera de manera suave al alcanzar la meta, evitando oscilaciones o bucles infinitos en las proximidades del destino.

### Definici√≥n de l√≠mites y buenas pr√°cticas de seguridad
El establecimiento de fronteras de operaci√≥n (TURTLE_MIN_X, TURTLE_MAX_X, etc.) y de l√≠mites de velocidad (MAX_LINEAR_SPEED, MAX_ANGULAR_SPEED) fue fundamental para asegurar un comportamiento seguro y estable. Adem√°s, la saturaci√≥n de la se√±al de control previno aceleraciones excesivas, manteniendo al robot dentro de una din√°mica predecible.

### Manejo de entrada en tiempo real y dise√±o multicadena
La implementaci√≥n de captura de teclado en modo raw, combinada con un hilo dedicado, permiti√≥ una interacci√≥n fluida y continua sin bloquear el ciclo principal de ROS. Esta separaci√≥n entre la lectura de entrada y la l√≥gica de control garantiz√≥ una actualizaci√≥n constante de la pose y un env√≠o de comandos con la cadencia requerida.

### Lecciones de ROS 2 en el proyecto
- **Modularidad de nodos**: El desarrollo de un nodo especializado (`KeyboardControllerNode`) simplific√≥ la extensi√≥n, prueba y mantenimiento del sistema.
- **Comunicaci√≥n basada en mensajes**: El uso de mensajes `Twist` y `Pose` evidenci√≥ el poder del sistema de t√≥picos de ROS 2 para desacoplar interfaces de usuario de la l√≥gica de movimiento.
- **Herramientas de ROS 2**: La utilizaci√≥n de componentes como `Duration`, `Rate`, `publishers` y `subscribers` permiti√≥ la gesti√≥n as√≠ncrona, segura y eficiente de la temporizaci√≥n y transmisi√≥n de datos.

## ‚ñ∂Ô∏è Video Explicativo

 [Labooratorio 1)](https://github.com/labsir-un/ROB_Intro_Linux.git)

## üìå Notas y Consejos

- **Enfoque de la terminal**: Aseg√∫rate de estar en la terminal desde la cual se lanz√≥ el nodo para poder ejecutar sus funciones correctamente.
- **L√≠mites de √°rea**: Si un punto meta est√° fuera de `[0+0.1, 11-0.1]` en `x` o `y`, se detiene el dibujo.
- **Velocidades**: Ajustar con `+` y `-` en tiempo real seg√∫n la precisi√≥n deseada.

---

## üêõ Contribuciones y Feedback

¬°Tu colaboraci√≥n es bienvenida! Si encuentras errores o tienes sugerencias, abre un _issue_ o env√≠a un _pull request_.

---

## üìÑ Licencia

Este proyecto est√° bajo la licencia **MIT**. ¬°Si√©ntete libre de usarlo y adaptarlo!

## Referencias

[1] [Labsir UN - Intro Linux (Repositorio en GitHub)](https://github.com/labsir-un/ROB_Intro_Linux.git)

[2] [Labsir UN - Intro ROS 2 Humble (Repositorio en GitHub)](https://github.com/labsir-un/ROB_Intro_ROS2_Humble.git)

[3] [Labsir UN - Intro Turtlesim (Repositorio en GitHub)](https://github.com/labsir-un/ROB_Intro_ROS2_Humble_Turtlesim.git)

[4] [ROS 2 Humble Installation Guide](https://docs.ros.org/en/humble/Installation.html)

[5] [Introducing Turtlesim - ROS 2 Humble Tutorial](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim.html)

[6] [Robotics Back-End (2022, 15 agosto) - Intro: Install and Setup ROS2 Humble - ROS2 Tutorial 1 (V√≠deo, YouTube)](https://www.youtube.com/watch?v=0aPbWsyENA8)

[7] [Muhammad Luqman (2023, 18 febrero) - Mathematics in Robotics: Go to Goal in ROS2 (V√≠deo, YouTube)](https://www.youtube.com/watch?v=SaZz-L3d_AE)


